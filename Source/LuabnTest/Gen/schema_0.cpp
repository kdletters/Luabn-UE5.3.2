
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#include "schema.h"

namespace cfg {


bool vector2::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;

    return true;
}

bool vector2::deserializevector2(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector2>& _out)
{
    _out.reset(new vector2());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vector3::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;
    if(!_buf.readFloat(z)) return false;

    return true;
}

bool vector3::deserializevector3(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector3>& _out)
{
    _out.reset(new vector3());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vector4::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;
    if(!_buf.readFloat(z)) return false;
    if(!_buf.readFloat(w)) return false;

    return true;
}

bool vector4::deserializevector4(::luban::ByteBuf& _buf, ::luban::SharedPtr<vector4>& _out)
{
    _out.reset(new vector4());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool CharacterData::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readInt(rare)) return false;
    if(!_buf.readInt(anim)) return false;
    if(!_buf.readInt(setting)) return false;
    if(!_buf.readInt(UI)) return false;
    if(!_buf.readInt(skin)) return false;

    return true;
}

bool CharacterData::deserializeCharacterData(::luban::ByteBuf& _buf, ::luban::SharedPtr<CharacterData>& _out)
{
    _out.reset(new CharacterData());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool CharacterAnim::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); idle.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<Character::AnimDia> _e; if(!Character::AnimDia::deserializeAnimDia(_buf, _e)) return false; idle.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); unused.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<Character::AnimDia> _e; if(!Character::AnimDia::deserializeAnimDia(_buf, _e)) return false; unused.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); touch.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<Character::AnimDia> _e; if(!Character::AnimDia::deserializeAnimDia(_buf, _e)) return false; touch.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); drag.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<Character::AnimDia> _e; if(!Character::AnimDia::deserializeAnimDia(_buf, _e)) return false; drag.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); inAdventure.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<Character::AnimDia> _e; if(!Character::AnimDia::deserializeAnimDia(_buf, _e)) return false; inAdventure.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); outAdventure.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<Character::AnimDia> _e; if(!Character::AnimDia::deserializeAnimDia(_buf, _e)) return false; outAdventure.push_back(_e);}}

    return true;
}

bool CharacterAnim::deserializeCharacterAnim(::luban::ByteBuf& _buf, ::luban::SharedPtr<CharacterAnim>& _out)
{
    _out.reset(new CharacterAnim());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Character::AnimDia::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readString(Anim)) return false;
    if(!_buf.readString(Dia)) return false;

    return true;
}

bool Character::AnimDia::deserializeAnimDia(::luban::ByteBuf& _buf, ::luban::SharedPtr<Character::AnimDia>& _out)
{
    _out.reset(new Character::AnimDia());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool CharacterSet::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(name)) return false;
    if(!_buf.readString(sex)) return false;
    if(!_buf.readString(age)) return false;
    if(!_buf.readString(introduce)) return false;

    return true;
}

bool CharacterSet::deserializeCharacterSet(::luban::ByteBuf& _buf, ::luban::SharedPtr<CharacterSet>& _out)
{
    _out.reset(new CharacterSet());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool CharacterUI::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(diaUI)) return false;
    if(!vector2::deserializevector2(_buf, position)) return false;

    return true;
}

bool CharacterUI::deserializeCharacterUI(::luban::ByteBuf& _buf, ::luban::SharedPtr<CharacterUI>& _out)
{
    _out.reset(new CharacterUI());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool CharacterSkin::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); skins.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::String _e; if(!_buf.readString(_e)) return false; skins.push_back(_e);}}

    return true;
}

bool CharacterSkin::deserializeCharacterSkin(::luban::ByteBuf& _buf, ::luban::SharedPtr<CharacterSkin>& _out)
{
    _out.reset(new CharacterSkin());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Rare::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readFloat(proportion)) return false;

    return true;
}

bool Rare::deserializeRare(::luban::ByteBuf& _buf, ::luban::SharedPtr<Rare>& _out)
{
    _out.reset(new Rare());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Translate::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readString(key)) return false;
    if(!_buf.readString(CN)) return false;
    if(!_buf.readString(EN)) return false;
    if(!_buf.readString(JP)) return false;

    return true;
}

bool Translate::deserializeTranslate(::luban::ByteBuf& _buf, ::luban::SharedPtr<Translate>& _out)
{
    _out.reset(new Translate());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Advenrture::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(name)) return false;
    if(!_buf.readInt(adventureTime)) return false;
    if(!_buf.readInt(restTime)) return false;
    if(!_buf.readInt(income)) return false;

    return true;
}

bool Advenrture::deserializeAdvenrture(::luban::ByteBuf& _buf, ::luban::SharedPtr<Advenrture>& _out)
{
    _out.reset(new Advenrture());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Income::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(name)) return false;
    if(!_buf.readFloat(proportion)) return false;

    return true;
}

bool Income::deserializeIncome(::luban::ByteBuf& _buf, ::luban::SharedPtr<Income>& _out)
{
    _out.reset(new Income());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Setting::deserialize(::luban::ByteBuf& _buf)
{

    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); IdelPlayInterval.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { EPlayInterval _k; {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; _k = EPlayInterval(__enum_temp__); } ::luban::int32 _v; if(!_buf.readInt(_v)) return false; IdelPlayInterval[_k] = _v;}}
    if(!_buf.readFloat(DialogueShowTime)) return false;

    return true;
}

bool Setting::deserializeSetting(::luban::ByteBuf& _buf, ::luban::SharedPtr<Setting>& _out)
{
    _out.reset(new Setting());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Record::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(name)) return false;
    if(!_buf.readInt(rare)) return false;
    if(!_buf.readString(fileName)) return false;

    return true;
}

bool Record::deserializeRecord(::luban::ByteBuf& _buf, ::luban::SharedPtr<Record>& _out)
{
    _out.reset(new Record());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Discoration::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(name)) return false;
    if(!_buf.readInt(rare)) return false;
    if(!_buf.readString(fileName)) return false;

    return true;
}

bool Discoration::deserializeDiscoration(::luban::ByteBuf& _buf, ::luban::SharedPtr<Discoration>& _out)
{
    _out.reset(new Discoration());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool Timer::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(name)) return false;
    if(!_buf.readInt(rare)) return false;
    if(!_buf.readString(fileName)) return false;

    return true;
}

bool Timer::deserializeTimer(::luban::ByteBuf& _buf, ::luban::SharedPtr<Timer>& _out)
{
    _out.reset(new Timer());
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}

}

